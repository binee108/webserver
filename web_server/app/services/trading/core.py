
"""Core trading execution logic extracted from the legacy trading service."""

from __future__ import annotations

import logging
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from decimal import Decimal, InvalidOperation
from typing import Any, Dict, List, Optional

from flask import current_app

from app import db
from app.models import Account, Strategy, StrategyAccount
from app.constants import Exchange, MarketType, OrderType
from app.services.exchange import exchange_service
from app.services.security import security_service

logger = logging.getLogger(__name__)


class TradingCore:
    """Encapsulates trading execution, signal processing, and exchange coordination."""

    def __init__(self, service: Optional[object] = None) -> None:
        self.service = service

    def execute_trade(self, strategy: Strategy, symbol: str, side: str,
                     quantity: Decimal, order_type: str,
                     price: Optional[Decimal] = None,
                     stop_price: Optional[Decimal] = None,
                     strategy_account_override: Optional[StrategyAccount] = None,
                     schedule_refresh: bool = True,
                     timing_context: Optional[Dict[str, float]] = None) -> Dict[str, Any]:
        """
        ê±°ë˜ ì‹¤í–‰ (í†µí•©ëœ ë¡œì§, ì•ˆì „ì¥ì¹˜ ì œê±°ë¨)

        Args:
            strategy: ì „ëµ ê°ì²´
            symbol: ì‹¬ë³¼
            side: ë§¤ìˆ˜/ë§¤ë„ ë°©í–¥ (BUY/SELL)
            quantity: ìˆ˜ëŸ‰
            order_type: ì£¼ë¬¸ ìœ í˜• (MARKET/LIMIT/STOP_MARKET/STOP_LIMIT)
            price: ê°€ê²© (ì§€ì •ê°€ ì£¼ë¬¸ì‹œ)
            stop_price: ìŠ¤íƒ‘ ê°€ê²© (ìŠ¤íƒ‘ ì£¼ë¬¸ì‹œ)
            strategy_account_override: íŠ¹ì • ì „ëµ ê³„ì¢Œë¡œ ê±°ë˜ë¥¼ ê°•ì œí•  ë•Œ ì‚¬ìš©

        Returns:
            ê±°ë˜ ì‹¤í–‰ ê²°ê³¼
        """
        try:
            logger.info(f"ê±°ë˜ ì‹¤í–‰ ì‹œì‘ - ì „ëµ: {strategy.name}, ì‹¬ë³¼: {symbol}, "
                       f"ì£¼ë¬¸: {side} {quantity} {order_type}")

            # ê³„ì • ì •ë³´ ì¡°íšŒ
            strategy_account = strategy_account_override or StrategyAccount.query.filter_by(
                strategy_id=strategy.id
            ).first()

            if not strategy_account or not strategy_account.account:
                return {
                    'success': False,
                    'error': 'ì „ëµì— ì—°ê²°ëœ ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤',
                    'error_type': 'account_error'
                }

            account = strategy_account.account

            # ë§ˆì¼“ íƒ€ì… ê²°ì • (ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´)
            strategy_market_type = getattr(strategy, 'market_type', 'SPOT').upper()
            market_type = 'futures' if strategy_market_type == 'FUTURES' else 'spot'

            logger.info(f"ğŸ“Š ì „ëµ ë§ˆì¼“íƒ€ì…: {strategy_market_type} â†’ ê±°ë˜ì†Œ ë§ˆì¼“íƒ€ì…: {market_type}")

            # ê±°ë˜ì†Œ ì£¼ë¬¸ ì‹¤í–‰ (íƒ€ì´ë° ì •ë³´ í¬í•¨)
            order_result = self._execute_exchange_order(
                account=account,
                symbol=symbol,
                side=side,
                quantity=quantity,
                order_type=order_type,
                market_type=market_type,
                price=price,
                stop_price=stop_price,
                timing_context=timing_context
            )

            order_result['account_id'] = account.id

            if not order_result['success']:
                return order_result

            # ì¡°ì •ëœ ìˆ˜ëŸ‰/ê°€ê²© ë³´ê´€ (ê±°ë˜ì†Œ ì œí•œ ë°˜ì˜)
            adjusted_quantity = order_result.get('adjusted_quantity', quantity)
            adjusted_price = order_result.get('adjusted_price', price)
            adjusted_stop_price = order_result.get('adjusted_stop_price', stop_price)

            fill_summary = self.service.position_manager.process_order_fill(
                strategy_account=strategy_account,
                order_id=order_result.get('order_id'),
                symbol=symbol,
                side=side,
                order_type=order_type,
                order_result=order_result,
                market_type=market_type
            )

            if not fill_summary.get('success'):
                logger.warning(
                    "ì²´ê²° ì²˜ë¦¬ë¥¼ ì™„ë£Œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤ - order_id=%s reason=%s",
                    order_result.get('order_id'),
                    fill_summary.get('error')
                )
                return {
                    'action': 'trading_signal',
                    'success': False,
                    'error': fill_summary.get('error'),
                    'order_id': order_result.get('order_id'),
                    'account_id': account.id,
                    'order_result': fill_summary.get('order_result')
                }

            order_result = fill_summary.get('order_result', order_result)
            filled_decimal = fill_summary.get('filled_quantity', Decimal('0'))
            average_decimal = fill_summary.get('average_price', Decimal('0'))

            # OpenOrder ë ˆì½”ë“œ ìƒì„± (ë¯¸ì²´ê²° ì£¼ë¬¸ì¸ ê²½ìš°)
            open_order_result = self.service.order_manager.create_open_order_record(
                strategy_account=strategy_account,
                order_result=order_result,
                symbol=symbol,
                side=side,
                order_type=order_type,
                quantity=adjusted_quantity,
                price=adjusted_price,
                stop_price=adjusted_stop_price
            )
            if open_order_result['success']:
                logger.info(f"ğŸ“ ë¯¸ì²´ê²° ì£¼ë¬¸ OpenOrder ì €ì¥: {order_result.get('order_id')}")
            else:
                logger.debug(f"OpenOrder ì €ì¥ ìŠ¤í‚µ: {open_order_result.get('reason', 'unknown')}")

            if not fill_summary.get('events_emitted'):
                self.service.event_emitter.emit_order_events_smart(strategy, symbol, side, adjusted_quantity, order_result)

            # ì‘ë‹µ ë°ì´í„° êµ¬ì„± (filled_quantityë¥¼ ìˆ«ìë¡œ ë³€í™˜, ì‹¤ì œ ì²´ê²°ê°€ ì‚¬ìš©)
            filled_qty_num = 0.0
            avg_price_num = 0.0

            try:
                if filled_decimal and filled_decimal > Decimal('0'):
                    filled_qty_num = float(filled_decimal)
            except (ValueError, TypeError):
                filled_qty_num = 0.0

            # average_price ê²°ì • (ì‹¤ì œ ì²´ê²°ê°€ ìš°ì„ )
            if average_decimal and average_decimal > Decimal('0'):
                avg_price_num = float(average_decimal)
            else:
                avg_price_num = float(order_result.get('actual_execution_price', 0) or 0)
                if avg_price_num <= 0:
                    avg_price_num = float(order_result.get('average_price', 0) or 0)
                if avg_price_num <= 0:
                    avg_price_num = float(order_result.get('adjusted_average_price', 0) or 0)

            # results ë°°ì—´ êµ¬ì„± (ì‹œì¥ê°€ ì£¼ë¬¸ ì²´ê²° ì •ë³´)
            results = []
            if filled_qty_num > 0 and avg_price_num > 0:
                results.append({
                    'symbol': symbol,
                    'side': side,
                    'executed_qty': filled_qty_num,
                    'executed_price': avg_price_num,
                    'trade_id': fill_summary.get('trade_id'),
                    'order_id': order_result.get('order_id'),
                    'timestamp': datetime.utcnow().isoformat()
                })

            result_payload = {
                'action': 'trading_signal',
                'success': True,
                'trade_id': fill_summary.get('trade_id'),
                'order_id': order_result.get('order_id'),
                'filled_quantity': filled_qty_num,  # ìˆ«ìë¡œ ë°˜í™˜
                'average_price': avg_price_num,  # ì‹¤ì œ ì²´ê²°ê°€ ë°˜í™˜
                'status': order_result.get('status'),
                'trade_status': fill_summary.get('trade_status'),
                'execution_status': fill_summary.get('execution_status'),
                'account_id': account.id,
                'results': results  # ì²´ê²° ìƒì„¸ ì •ë³´ ë°°ì—´
            }


            if schedule_refresh:
                security_service.refresh_account_balance_async(account.id)

            return result_payload

        except Exception as e:
            logger.error(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            failure_payload = {
                'action': 'trading_signal',
                'success': False,
                'error': str(e),
                'error_type': 'execution_error'
            }
            if 'account_id' not in failure_payload and 'account' in locals() and account:
                failure_payload['account_id'] = account.id
            return failure_payload


